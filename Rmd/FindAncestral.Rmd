---
title: "Looking for Ancestral alleles"
author: "Bruce Cochrane"
date: "10/15/2016"
output: html_document
---
Attempt to parse files for ancestral allele information

```{r}
dat <-read.vcf("./Data/lct.ceu-yri.vcf.gz")
dat.info <-VCFloci("./Data/lct.ceu-yri.vcf.gz")
```

Combined yri-ceu data loaded - now focus on dat.info file

```{r}
str(dat.info)
```

Look at the first one

```{r}
test <- dat.info[12,]
test
```

OK.  I think AA is the key - if it is 0, then is it the major allele that is ancestral

```{r}
test2 <-test$INFO
test2
```

Split out the field

```{r}
test.spl <-strsplit(test2,";")
```

```{r}
test.spl <-unlist(test.spl)
AA <-substr(test.spl[1],4,4)
AA
```

OK.  If it's always in that position, we could automate this, generating a list of ancestral alleles.  We would then need to mung it into rehh format - not fun, but doable

```{r}
test.spl <-gsub("|||","", test.spl[1],fixed=TRUE)
AA <-sapply(strsplit(as.character(test.spl),""),tail,1)
AA
```

OK, so that seems kind of grubby, but we should be able to functionalize.  One more little try

```{r}
test3 <-dat.info$INFO
test3.spl <-sapply(test3, strsplit,";")
names(test)=dat.info$ID
```

Make the first element into a vector

```{r}
test3.all <-do.call(rbind,test3.spl) 
```

Still kind of messy - we need to filter out those that don't have AA.

```{r}
test4 <-test3.all[,1]
has.aa <-which(substr(test4,1,2)=="AA")
test4.aa <-test4[has.aa]
head(test4.aa)
dat.anc <-gsub("|||",";",test4.aa,fixed=TRUE)
dat.anc2 <-sapply(dat.anc,substr,4,4)
```

OK.  Enough for now.  We can extract and functionalize that pretty easily; then we need to work on the formatting bit for rehh.  But that's for another day.  we also have to filter out the N's and deal with upper and lower cases (not sure what they mean.

### Using function

```{r}
aa <-get.ancestral(dat.info)
table(aa)
```

Looks good.  Got a warning, but that is probably ok.

```{r}
which(aa=="N")
```

So there are a few problems:

1.  some have N - that's ok, we have to exclude them.
2.  We have to figure out the lower and upper
3.  A few have either - or ;.  Those we need to explore

```{r}
dashes <-names(aa[which(aa=="-")])
dashes
```

So this is the problem - we've reindexed everything by deleting the ones with absences.  what we need to do is to look at the original data by snp

```{r}
dat.dash <-dat.info$INFO[which(dat.info$ID %in% dashes)]
dat.dash
```

So all of them need to be excluded.  However, it might be better to replace everything with NA. And much of this might be obviated if we got rid of indels etc. before processing (those are wht the dashes are).

### Tuning the function

1.  suppress warnings - they are annoying
2.  perhaps have it return both allele and index in original data frame (or even subsetted frame?  Command would be something like

```{r}
ind <-which(dat.info$ID %in% names(dat.anc))
dat.aa.info <-dat.info[ind,]
dat.aa <-dat[,ind]
```

OK.  So with that little piece included, we now have a vcf (dat.aa) and an info (dat.aa.info) file, which includes only those with an AA field.  This is becoming clearer - what the function needs to do is to

1.  Remove at least the N's, -'s and ;'s
2.  perhaps have an option to keep lower case bases or not
3.  Do the subsetting

And we still need to figure out how to deal with the subsetting.  Perhaps just a second short function of on the order of

clean.vcf(dat.vcf,dat.info,dat.anc)

I like that.  Then, of course, we have to build the rehh files.  But that's for another day.  Actually, we'll probably need to work from the pedfiles (or the haplotypes generated by haplo.em.